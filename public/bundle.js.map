{"version":3,"file":"bundle.js","sources":["../node_modules/gl-matrix/esm/common.js","../node_modules/gl-matrix/esm/vec3.js","../src/utils.js","../src/mac-grid.js","../src/particles.js","../src/simulation/add-gravity.js","../src/simulation/advect-particles.js","../src/simulation/classify-voxels.js","../src/simulation/copy-kernel.js","../src/simulation/enforce-boundary-conditions.js","../src/simulation/transfer-particle-to-grid.js","../src/simulation/transfer-grid-to-particles.js","../src/simulation/kernels.js","../src/simulation/simulation.js","../src/main.js"],"sourcesContent":["/**\r\n * Common utilities\r\n * @module glMatrix\r\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\r\n * Sets the type of array used when creating new vectors and matrices\r\n *\r\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\r\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\r\n * Convert Degree To Radian\r\n *\r\n * @param {Number} a Angle in Degrees\r\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\r\n * Tests whether or not the arguments have approximately the same value, within an absolute\r\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\r\n * than or equal to 1.0, and a relative tolerance is used for larger values)\r\n *\r\n * @param {Number} a The first number to test.\r\n * @param {Number} b The second number to test.\r\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\r\n * 3 Dimensional Vector\r\n * @module vec3\r\n */\n\n/**\r\n * Creates a new, empty vec3\r\n *\r\n * @returns {vec3} a new 3D vector\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec3 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec3} a vector to clone\r\n * @returns {vec3} a new 3D vector\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Calculates the length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Creates a new vec3 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} a new 3D vector\r\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Copy the values from one vec3 to another\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the source vector\r\n * @returns {vec3} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Set the components of a vec3 to the given values\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} out\r\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Adds two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\r\n * Multiplies two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\r\n * Divides two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to ceil\r\n * @returns {vec3} out\r\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to floor\r\n * @returns {vec3} out\r\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to round\r\n * @returns {vec3} out\r\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\r\n * Scales a vec3 by a scalar number\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec3} out\r\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\r\n * Adds two vec3's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec3} out\r\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Calculates the squared length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Negates the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to negate\r\n * @returns {vec3} out\r\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to invert\r\n * @returns {vec3} out\r\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\r\n * Normalize a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to normalize\r\n * @returns {vec3} out\r\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\r\n * Computes the cross product of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\r\n * Performs a hermite interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {ReadonlyVec3} c the third operand\r\n * @param {ReadonlyVec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Performs a bezier interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {ReadonlyVec3} c the third operand\r\n * @param {ReadonlyVec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec3} out\r\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat4.\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat3.\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\r\n * Transforms the vec3 with a quat\r\n * Can also be used for dual quaternions. (Multiply it with the real part)\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyQuat} q quaternion to transform with\r\n * @returns {vec3} out\r\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the x-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the y-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the z-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Get the angle between two 3D vectors\r\n * @param {ReadonlyVec3} a The first operand\r\n * @param {ReadonlyVec3} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\r\n * Set the components of a vec3 to zero\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @returns {vec3} out\r\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec3} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec3} a The first vector.\r\n * @param {ReadonlyVec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec3} a The first vector.\r\n * @param {ReadonlyVec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\r\n * Alias for {@link vec3.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;\n/**\r\n * Alias for {@link vec3.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link vec3.divide}\r\n * @function\r\n */\n\nexport var div = divide;\n/**\r\n * Alias for {@link vec3.distance}\r\n * @function\r\n */\n\nexport var dist = distance;\n/**\r\n * Alias for {@link vec3.squaredDistance}\r\n * @function\r\n */\n\nexport var sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec3.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Alias for {@link vec3.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec3s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","/**\n * Create a new 3D array of zeros with the given dimensions.\n *\n * @param {number} x x dimension length\n * @param {number} y y dimension length\n * @param {number} z z dimension length\n * @returns The new array, all values set to zero.\n */\nexport const initialize3DArray = (x, y, z) => {\n  let a = [];\n  for (let i = 0; i < x; i++) {\n    a.push([]);\n    for (let j = 0; j < y; j++) {\n      a[i].push(new Float32Array(z));\n    }\n  }\n  a.toArray = function() {return this;}\n  return a;\n};\n","import { vec3 } from \"gl-matrix\";\nimport { initialize3DArray } from \"./utils.js\";\n\n/** Enum for voxel states. */\nexport const STATE_ENUM = {\n  AIR: 0,\n  FLUID: 1,\n  SOLID: 2,\n};\n\n/**\n * Represent a MAC grid and the quantities associated with it. See Bridson,\n * 2015, chapter 2 for details on the structure of the grid. Pressures are\n * stored at the center of each voxel, and normal velocities are stored at the\n * boundaries on the voxels.\n */\nexport class MACGrid {\n  /**\n   * Construct a new MAC grid with the given specification. This grid\n   * construction is based off of Austin Eng's representation.\n   *\n   * @param {{min: vec3, max: vec3}} boundaries The bounds of the grid.\n   * @param {number} cellSize The width of each voxel.\n   */\n  constructor(boundaries, cellSize) {\n    this.min = boundaries.min;\n    this.max = boundaries.max;\n\n    // adjust the max extent to align to an integer number of cells\n    vec3.set(\n      this.max,\n      this.min[0] +\n        cellSize * Math.ceil((this.max[0] - this.min[0]) / cellSize),\n      this.min[1] +\n        cellSize * Math.ceil((this.max[1] - this.min[1]) / cellSize),\n      this.min[2] + cellSize * Math.ceil((this.max[2] - this.min[2]) / cellSize)\n    );\n\n    this.cellSize = cellSize;\n    this.count = vec3.create();\n    this.size = vec3.create();\n    vec3.sub(this.size, this.max, this.min);\n    vec3.scale(this.count, this.size, 1.0 / this.cellSize);\n    vec3.add(this.count, this.count, vec3.fromValues(1, 1, 1));\n    vec3.floor(this.count, this.count);\n\n    /// initialize\n    this.nx = this.count[0] - 1;\n    this.ny = this.count[1] - 1;\n    this.nz = this.count[2] - 1;\n    this.pressure = initialize3DArray(this.nx, this.ny, this.nz);\n    this.pressureOld = null;\n    this.velocityX = [[[\"hi\"]]];//initialize3DArray(this.nx + 1, this.ny, this.nz);\n    this.velocityXOld = null;\n    this.velocityY = null;//initialize3DArray(this.nx, this.ny + 1, this.nz);\n    this.velocityYOld = null;\n    this.velocityZ = null;//initialize3DArray(this.nx, this.ny, this.nz + 1);\n    this.velocityZOld = null;\n\n    // initialize voxel states\n    this.voxelStates = initialize3DArray(this.nx, this.ny, this.nz);\n\n    console.log(\n      `Created a MAC grid with dimensions (${this.nx}, ${this.ny}, ${this.nz}).`\n    );\n  }\n\n  /**\n   * Set all voxels on the boundary of the grid to be solids. Leave everything\n   * else untouched (by default, air).\n   */\n  addDefaultSolids() {\n    for (let i = 0; i < this.nx; i++) {\n      for (let j = 0; j < this.ny; j++) {\n        for (let k = 0; k < this.nz; k++) {\n          if (\n            i === 0 ||\n            j === 0 ||\n            k === 0 ||\n            i === this.nx - 1 ||\n            j === this.ny - 1 ||\n            k === this.nz - 1\n          ) {\n            this.voxelStates[i][j][k] = STATE_ENUM.SOLID;\n          }\n        }\n      }\n    }\n  }\n}\n","export const ATTRIBUTE_COUNT = 6;\n\n/**\n * Represent the particle cloud.\n */\nexport class Particles {\n  /**\n   * Create a set of particles. The density of the particles determines how\n   * many are made, and the bounds determine the initial position of the\n   * particles. They start out evenly distributed throughout this box.\n   *\n   * @param {number} density\n   * @param {{min: vec3, max: vec3}} bounds The initial minimum and maximum\n   * extent of the box of particles.\n   */\n  constructor(density, bounds) {\n    this.particleBuffer = [];\n    this.particleIndices = [];\n    let particle_counter = 0;\n    let gap_between = 1 / Math.cbrt(density);\n    for (let x = bounds.min[0]; x < bounds.max[0]; x += gap_between) {\n      for (let y = bounds.min[1]; y < bounds.max[1]; y += gap_between) {\n        for (let z = bounds.min[2]; z < bounds.max[2]; z += gap_between) {\n          // push initial particle quantities\n          this.particleBuffer.push(x); // initial position\n          this.particleBuffer.push(y);\n          this.particleBuffer.push(z);\n          this.particleBuffer.push(0); // initial velocity\n          this.particleBuffer.push(0);\n          this.particleBuffer.push(0);\n\n          // push particles indices\n          this.particleIndices.push(particle_counter++ * ATTRIBUTE_COUNT);\n        }\n      }\n    }\n    console.log(`Created ${this.count()} particles.`);\n  }\n\n  /**\n   * @returns The count of particles in the cloud.\n   */\n  count() {\n    return this.particleBuffer.length / ATTRIBUTE_COUNT;\n  }\n\n  /**\n   * Get the ith particle from the buffer.\n   *\n   * @param {number} i The index of the particle to retrieve.\n   * @returns The particle as an object.\n   */\n  get(i) {\n    if (i < 0 || i >= this.count()) {\n      console.error(\"Index out of bounds in particle buffer!\");\n      return null;\n    }\n\n    return {\n      x_position: this.particleBuffer[ATTRIBUTE_COUNT * i],\n      y_position: this.particleBuffer[ATTRIBUTE_COUNT * i + 1],\n      z_position: this.particleBuffer[ATTRIBUTE_COUNT * i + 2],\n      x_velocity: this.particleBuffer[ATTRIBUTE_COUNT * i + 3],\n      y_velocity: this.particleBuffer[ATTRIBUTE_COUNT * i + 4],\n      z_velocity: this.particleBuffer[ATTRIBUTE_COUNT * i + 5],\n    };\n  }\n}\n","export const createAddGravityKernel = (gpu, nx, ny, nz) =>\n  gpu\n    .createKernel(function (velocity_y, dt) {\n      return (\n        velocity_y[this.thread.z][this.thread.y][this.thread.x] - dt * 1\n      );\n    })\n    .setOutput([nx, ny, nz]);\n","import { ATTRIBUTE_COUNT } from \"../particles.js\";\n\nexport const createAdvectParticlesKernel = (gpu, particleCount, cellSize) =>\n  gpu\n    .createKernel(function (\n      particles,\n      dt,\n      velocityFieldX,\n      velocityFieldY,\n      velocityFieldZ\n    ) {\n      // check which position component we're looking at\n      if (this.thread.x % this.constants.ATTRIBUTE_COUNT === 0) {\n        // get position\n        let x = particles[this.thread.x];\n        let y = particles[this.thread.x + 1];\n        let z = particles[this.thread.x + 2];\n\n        // get x velocity\n        let vx = particles[this.thread.x + 3];\n\n        // carry out 2nd order Runge-Kutta solver in one dimension\n        let k1 = dt * vx;\n        let xIntermediate = x + k1 / 2;\n\n        // interpolate the velocity at the intermediate x value\n        let lerpWeight =\n          (xIntermediate -\n            Math.floor(xIntermediate) * this.constants.CELL_SIZE) /\n          this.constants.CELL_SIZE;\n        let vxIntermediate = lerp(\n          velocityFieldX[Math.floor(z / this.constants.CELL_SIZE)][\n            Math.floor(y / this.constants.CELL_SIZE)\n          ][Math.floor(xIntermediate / this.constants.CELL_SIZE)],\n          velocityFieldX[Math.floor(z / this.constants.CELL_SIZE)][\n            Math.floor(y / this.constants.CELL_SIZE)\n          ][Math.ceil(xIntermediate / this.constants.CELL_SIZE)],\n          lerpWeight\n        );\n        let k2 = dt * vxIntermediate;\n        return x + k2;\n      } else if (this.thread.x % this.constants.ATTRIBUTE_COUNT === 1) {\n        // get position\n        let x = particles[this.thread.x - 1];\n        let y = particles[this.thread.x];\n        let z = particles[this.thread.x + 1];\n\n        // get y velocity\n        let vy = particles[this.thread.x + 3];\n\n        // carry out 2nd order Runge-Kutta solver in one dimension\n        let k1 = dt * vy;\n        let yIntermediate = y + k1 / 2;\n\n        // interpolate the velocity at the intermediate y value\n        let lerpWeight =\n          (yIntermediate -\n            Math.floor(yIntermediate) * this.constants.CELL_SIZE) /\n          this.constants.CELL_SIZE;\n        let vyIntermediate = lerp(\n          velocityFieldY[Math.floor(z / this.constants.CELL_SIZE)][\n            Math.floor(yIntermediate / this.constants.CELL_SIZE)\n          ][Math.floor(x / this.constants.CELL_SIZE)],\n          velocityFieldY[Math.floor(z / this.constants.CELL_SIZE)][\n            Math.ceil(yIntermediate / this.constants.CELL_SIZE)\n          ][Math.floor(x / this.constants.CELL_SIZE)],\n          lerpWeight\n        );\n        let k2 = dt * vyIntermediate;\n        return y + k2;\n      } else if (this.thread.x % this.constants.ATTRIBUTE_COUNT === 2) {\n        // get position\n        let x = particles[this.thread.x - 2];\n        let y = particles[this.thread.x - 1];\n        let z = particles[this.thread.x];\n\n        // get z velocity\n        let vz = particles[this.thread.x + 3];\n\n        // carry out 2nd order Runge-Kutta solver in one dimension\n        let k1 = dt * vz;\n        let zIntermediate = z + k1 / 2;\n\n        // interpolate the velocity at the intermediate z value\n        let lerpWeight =\n          (zIntermediate -\n            Math.floor(zIntermediate) * this.constants.CELL_SIZE) /\n          this.constants.CELL_SIZE;\n        let vzIntermediate = lerp(\n          velocityFieldZ[Math.floor(zIntermediate / this.constants.CELL_SIZE)][\n            Math.floor(y / this.constants.CELL_SIZE)\n          ][Math.floor(x / this.constants.CELL_SIZE)],\n          velocityFieldZ[Math.ceil(zIntermediate / this.constants.CELL_SIZE)][\n            Math.floor(y / this.constants.CELL_SIZE)\n          ][Math.floor(x / this.constants.CELL_SIZE)],\n          lerpWeight\n        );\n        let k2 = dt * vzIntermediate;\n        return z + k2;\n      } else {\n        // don't change the velocities\n        return particles[this.thread.x];\n      }\n    })\n    .addFunction(function lerp(a, b, t) {\n      return (1 - t) * a + t * b;\n    })\n    .setConstants({ ATTRIBUTE_COUNT: ATTRIBUTE_COUNT, CELL_SIZE: cellSize })\n    .setOutput([ATTRIBUTE_COUNT * particleCount]);\n","import { STATE_ENUM } from \"../mac-grid.js\";\n\nexport const createClassifyVoxelsKernel = (gpu, particleCount, nx, ny, nz) =>\n  gpu\n    .createKernel(function (voxelStates, particles, cellSize) {\n      // get spatial location of grid\n      let x = cellSize * this.thread.x;\n      let y = cellSize * this.thread.y;\n      let z = cellSize * this.thread.z;\n\n      let particle_exists = false;\n      for (let i = 0; i < this.constants.particleCount; i++) {\n        let pos_x = particles[i * 6];\n        let pos_y = particles[i * 6 + 1];\n        let pos_z = particles[i * 6 + 2];\n        // check if there is a particle in that grid\n        if (\n          pos_x - x <= cellSize &&\n          pos_x - x > 0 &&\n          pos_y - y <= cellSize &&\n          pos_y - y > 0 &&\n          pos_z - z <= cellSize &&\n          pos_z - z > 0\n        ) {\n          particle_exists = true;\n          break;\n        }\n      }\n      // set any cell with a particle in it that isn't solid to fluid\n      // any cell without a particle or solid is air\n      if (particle_exists) {\n        if (\n          voxelStates[this.thread.z][this.thread.y][this.thread.x] !==\n          this.constants.SOLID\n        ) {\n          return this.constants.FLUID;\n        } else {\n          return this.constants.SOLID;\n        }\n      } else {\n        // if there isn't, and the state is fluid, flip it to air\n        if (\n          voxelStates[this.thread.z][this.thread.y][this.thread.x] !==\n          this.constants.SOLID\n        ) {\n          return this.constants.AIR;\n        } else {\n          return this.constants.SOLID;\n        }\n      }\n    })\n    .setConstants({\n      particleCount: particleCount,\n      AIR: STATE_ENUM.AIR,\n      FLUID: STATE_ENUM.FLUID,\n      SOLID: STATE_ENUM.SOLID,\n    })\n    .setOutput([nx, ny, nz]);\n","export const createCopyKernel = (gpu, nx, ny, nz) =>\n  gpu\n    .createKernel(function (array) {\n      return array[this.thread.z][this.thread.y][this.thread.x];\n    })\n    .setOutput([nx, ny, nz]);\n","/**\n * Assumption!\n * This assumes that we're using the default arrangement of having all solid\n * voxels around the edge of our rectangular domain.\n */\n\nexport const createEnforceBoundaryXKernel = (gpu, nx, ny, nz) =>\n  gpu\n    .createKernel(function (velocities) {\n      if (this.thread.x === 1 || this.thread.x === this.constants.nx - 2) {\n        return 0;\n      }\n      return velocities[this.thread.z][this.thread.y][this.thread.x];\n    })\n    .setConstants({ nx: nx })\n    .setOutput([nx, ny, nz]);\n\nexport const createEnforceBoundaryYKernel = (gpu, nx, ny, nz) =>\n  gpu\n    .createKernel(function (velocities) {\n      if (this.thread.y === 1 || this.thread.y === this.constants.ny - 2) {\n        return 0;\n      }\n      return velocities[this.thread.z][this.thread.y][this.thread.x];\n    })\n    .setConstants({ ny: ny })\n    .setOutput([nx, ny, nz]);\n\nexport const createEnforceBoundaryZKernel = (gpu, nx, ny, nz) =>\n  gpu\n    .createKernel(function (velocities) {\n      if (this.thread.z === 1 || this.thread.z === this.constants.nz - 2) {\n        return 0;\n      }\n      return velocities[this.thread.z][this.thread.y][this.thread.x];\n    })\n    .setConstants({ nz: nz })\n    .setOutput([nx, ny, nz]);\n","/**\n * Transfer particle velocities to the grid. See Bridson, section 7.6 on\n * particle methods.\n */\n\n/**\n * How to parallelize?\n *\n *\n * for each particle:\n *  - get position of particle\n *  - find grid edges within dx\n *  for each of these edges:\n *      - add velocity * weight\n *      - where weight is given as triangle function\n */\nexport const createParticleToGridKernel = (\n  gpu,\n  particleCount,\n  nx,\n  ny,\n  nz,\n  dimension\n) =>\n  gpu\n    .createKernel(function (particles, cellSize) {\n      // get spatial location of grid velocity vector\n      let x = cellSize * this.thread.x;\n      let y = cellSize * this.thread.y;\n      let z = cellSize * this.thread.z;\n\n      // declare numerator and denominator of the weighted sum\n      let numerator = 0;\n      let denominator = 0;\n      /* loop through particles to find ones that are close, add their\n         velocity contribution to the grid velocity */\n      for (\n        let particleIndex = 0;\n        particleIndex < this.constants.PARTICLE_COUNT;\n        particleIndex++\n      ) {\n        // calculate distance in each dimension\n        let distance_x = particles[particleIndex * 6] - x;\n        let distance_y = particles[particleIndex * 6 + 1] - y;\n        let distance_z = particles[particleIndex * 6 + 2] - z;\n\n        // if it's far, skip it\n        if (\n          Math.abs(distance_x) > cellSize ||\n          Math.abs(distance_y) > cellSize ||\n          Math.abs(distance_z) > cellSize\n        ) {\n          continue;\n        }\n\n        // calculate the weight according to the trilinear interpolation\n        let weight =\n          triangle(distance_x / cellSize) *\n          triangle(distance_y / cellSize) *\n          triangle(distance_z / cellSize);\n\n        numerator +=\n          particles[particleIndex * 6 + 3 + this.constants.DIMENSION] * weight;\n        denominator += weight;\n      }\n\n      // check for divide by zero\n      if (Math.abs(denominator) < 0.0001) {\n        return 0;\n      }\n      return numerator / denominator;\n    })\n    .addFunction(function triangle(r) {\n      let r_magnitude = Math.abs(r);\n      if (r_magnitude >= 1) {\n        return 0;\n      }\n      return 1 - r_magnitude;\n    })\n    .setConstants({ PARTICLE_COUNT: particleCount, DIMENSION: dimension })\n    .setOutput([nx, ny, nz]);\n","import { ATTRIBUTE_COUNT } from \"../particles.js\";\n\n// kernel for subracting the new grid velocities from the old grid velocities\nconst createGridVelocityDifferenceKernel = (gpu, nx, ny, nz) =>\n  gpu\n    .createKernel(function (oldVelocities, newVelocities) {\n      return (\n        newVelocities[this.thread.z][this.thread.y][this.thread.x] -\n        oldVelocities[this.thread.z][this.thread.y][this.thread.x]\n      );\n    })\n    .setOutput([nx, ny, nz]);\n\n// FLIP Kernel\nconst createFLIPKernel = (gpu, particleCount, cellSize) =>\n  gpu\n    .createKernel(function (particles, diffGridVx, diffGridVy, diffGridVz) {\n      // mod to figure out which index we are at (0-5) for each particle\n      let index_mod = this.thread.x % this.constants.ATTRIBUTE_COUNT;\n      // if we are looking at the position just return the position\n      if (index_mod === 0 || index_mod === 1 || index_mod === 2) {\n        return particles[this.thread.x];\n      }\n      // get the positions - index changes depending which velocity we are looking at\n      let pos_x = particles[this.thread.x - index_mod];\n      let pos_y = particles[this.thread.x - index_mod + 1];\n      let pos_z = particles[this.thread.x - index_mod + 2];\n      // get the lower and upper grid positions\n      let grid_lower_x = Math.floor(pos_x / this.constants.CELL_SIZE);\n      let grid_upper_x = Math.ceil(pos_x / this.constants.CELL_SIZE);\n      let grid_lower_y = Math.floor(pos_y / this.constants.CELL_SIZE);\n      let grid_upper_y = Math.ceil(pos_y / this.constants.CELL_SIZE);\n      let grid_lower_z = Math.floor(pos_z / this.constants.CELL_SIZE);\n      let grid_upper_z = Math.ceil(pos_z / this.constants.CELL_SIZE);\n      if (index_mod === 3) {\n        // vx\n        // get the lerp weight and return the lerp'd velocity\n        let lerpWeight =\n          (pos_x - grid_lower_x * this.constants.CELL_SIZE) /\n          this.constants.CELL_SIZE;\n        return lerp(\n          diffGridVx[grid_lower_z][grid_lower_y][grid_lower_x],\n          diffGridVx[grid_lower_z][grid_lower_y][grid_upper_x],\n          lerpWeight\n        );\n      } else if (index_mod === 4) {\n        // vy\n        // get the lerp weight and return the lerp'd velocity\n        let lerpWeight =\n          (pos_y - grid_lower_y * this.constants.CELL_SIZE) /\n          this.constants.CELL_SIZE;\n        return lerp(\n          diffGridVy[grid_lower_z][grid_lower_y][grid_lower_x],\n          diffGridVy[grid_lower_z][grid_upper_y][grid_lower_x],\n          lerpWeight\n        );\n      } else if (index_mod === 5) {\n        // vz\n        // get the lerp weight and return the lerp'd velocity\n        let lerpWeight =\n          (pos_z - grid_lower_z * this.constants.CELL_SIZE) /\n          this.constants.CELL_SIZE;\n        return lerp(\n          diffGridVz[grid_lower_z][grid_lower_y][grid_lower_x],\n          diffGridVz[grid_upper_z][grid_lower_y][grid_lower_x],\n          lerpWeight\n        );\n      }\n    })\n    .addFunction(function lerp(a, b, t) {\n      return (1 - t) * a + t * b;\n    })\n    .setConstants({ ATTRIBUTE_COUNT: ATTRIBUTE_COUNT, CELL_SIZE: cellSize })\n    .setOutput([particleCount * ATTRIBUTE_COUNT]);\n\nexport const createGridToParticlesKernel = (\n  gpu,\n  particleCount,\n  nx,\n  ny,\n  nz,\n  cellSize\n) => {\n  const velocityXDifference = createGridVelocityDifferenceKernel(\n    gpu,\n    nx + 1,\n    ny,\n    nz\n  ).setPipeline(true);\n  const velocityYDifference = createGridVelocityDifferenceKernel(\n    gpu,\n    nx,\n    ny + 1,\n    nz\n  ).setPipeline(true);\n  const velocityZDifference = createGridVelocityDifferenceKernel(\n    gpu,\n    nx,\n    ny,\n    nz + 1\n  ).setPipeline(true);\n  const flipKernel = createFLIPKernel(gpu, particleCount, cellSize).setPipeline(true);\n  /*return gpu.combineKernels(\n    velocityXDifference,\n    velocityYDifference,\n    velocityZDifference,\n    flipKernel,\n    function (\n      oldXVelocity,\n      oldYVelocity,\n      oldZVelocity,\n      newXVelocity,\n      newYVelocity,\n      newZVelocity,\n      particles\n    ) {\n      return flipKernel(\n        particles,\n        velocityXDifference(oldXVelocity, newXVelocity),\n        velocityYDifference(oldYVelocity, newYVelocity),\n        velocityZDifference(oldZVelocity, newZVelocity)\n      );\n    }\n  );*/\n  return function (\n    oldXVelocity,\n    oldYVelocity,\n    oldZVelocity,\n    newXVelocity,\n    newYVelocity,\n    newZVelocity,\n    particles\n  ) {\n    return flipKernel(\n      particles,\n      velocityXDifference(oldXVelocity, newXVelocity),\n      velocityYDifference(oldYVelocity, newYVelocity),\n      velocityZDifference(oldZVelocity, newZVelocity)\n    );\n  };\n};\n","import { createAddGravityKernel } from \"./add-gravity.js\";\nimport { createAdvectParticlesKernel } from \"./advect-particles.js\";\nimport { createClassifyVoxelsKernel } from \"./classify-voxels.js\";\nimport { createCopyKernel } from \"./copy-kernel.js\";\nimport {\n  createEnforceBoundaryXKernel,\n  createEnforceBoundaryYKernel,\n  createEnforceBoundaryZKernel,\n} from \"./enforce-boundary-conditions.js\";\nimport { createParticleToGridKernel } from \"./transfer-particle-to-grid.js\";\nimport { createGridToParticlesKernel } from \"./transfer-grid-to-particles.js\";\n\nexport const compileKernels = (gpu, particles, grid) => {\n  const start = Date.now();\n\n  const gridSize = [grid.nx, grid.ny, grid.nz];\n  const velocityXSize = [grid.nx + 1, grid.ny, grid.nz];\n  const velocityYSize = [grid.nx, grid.ny + 1, grid.nz];\n  const velocityZSize = [grid.nx, grid.ny, grid.nz + 1];\n\n  // project particle velocities to the grid\n  const particleToXGrid = createParticleToGridKernel(\n    gpu,\n    particles.count(),\n    ...velocityXSize,\n    0\n  );\n  const particleToYGrid = createParticleToGridKernel(\n    gpu,\n    particles.count(),\n    ...velocityYSize,\n    1\n  );\n  const particleToZGrid = createParticleToGridKernel(\n    gpu,\n    particles.count(),\n    ...velocityZSize,\n    2\n  );\n\n  // copy grid quantities to save\n  const copyPressure = createCopyKernel(gpu, ...gridSize);\n  const copyXVelocity = createCopyKernel(gpu, ...velocityXSize);\n  const copyYVelocity = createCopyKernel(gpu, ...velocityYSize);\n  const copyZVelocity = createCopyKernel(gpu, ...velocityZSize);\n\n  // mark cells as solid, fluid, or air\n  const classifyVoxels = createClassifyVoxelsKernel(\n    gpu,\n    particles.count(),\n    ...gridSize\n  );\n\n  // add gravitational influence\n  const addGravity = createAddGravityKernel(gpu, ...velocityYSize);\n\n  // enforce boundary conditions\n  const enforceXBoundary = createEnforceBoundaryXKernel(gpu, ...velocityXSize);\n  const enforceYBoundary = createEnforceBoundaryYKernel(gpu, ...velocityYSize);\n  const enforceZBoundary = createEnforceBoundaryZKernel(gpu, ...velocityZSize);\n\n  // do pressure solve\n  // TODO: implement these kernels\n\n  // update the velocities of the particles using PIC/FLIP\n  const gridToParticles = createGridToParticlesKernel(\n    gpu,\n    particles.count(),\n    ...gridSize,\n    grid.cellSize\n  );\n\n  // update the positions of the particles\n  const advectParticles = createAdvectParticlesKernel(\n    gpu,\n    particles.count(),\n    grid.cellSize\n  );\n\n  const end = Date.now();\n  console.log(`Kernels compiled in ${end - start} ms.`);\n\n  return {\n    particleToXGrid: particleToXGrid.setPipeline(true),\n    particleToYGrid: particleToYGrid.setPipeline(true),\n    particleToZGrid: particleToZGrid.setPipeline(true),\n    copyPressure: copyPressure.setPipeline(true),\n    copyXVelocity: copyXVelocity.setPipeline(true),\n    copyYVelocity: copyYVelocity.setPipeline(true),\n    copyZVelocity: copyZVelocity.setPipeline(true),\n    classifyVoxels: classifyVoxels.setPipeline(true),\n    addGravity: addGravity.setPipeline(true),\n    enforceXBoundary: enforceXBoundary.setPipeline(true),\n    enforceYBoundary: enforceYBoundary.setPipeline(true),\n    enforceZBoundary: enforceZBoundary.setPipeline(true),\n    gridToParticles: gridToParticles,\n    advectParticles: advectParticles.setPipeline(true),\n  };\n};\n","import { MACGrid } from \"../mac-grid.js\";\nimport { Particles } from \"../particles.js\";\nimport { compileKernels } from \"./kernels.js\";\n\nexport class Simulation {\n  constructor(gpu, config) {\n    this.particles = new Particles(\n      config.particleDensity,\n      config.particleBounds\n    );\n    this.grid = new MACGrid(\n      config.gridBounds,\n      //2.0 / Math.cbrt(config.particleDensity)\n      0.05\n    );\n    this.kernels = compileKernels(gpu, this.particles, this.grid);\n  }\n\n  step(dt) {\n    let particleBufferCopy = new Float32Array(this.particles.particleBuffer);\n    console.log(\"SIM START\")\n    // transfer particle velocities to the grid and interpolate\n    //console.log(\"1: \" + this.grid.velocityX[0][0][0])\n    console.log(this.particles.particleBuffer)\n    this.grid.velocityX = this.kernels.particleToXGrid(\n      particleBufferCopy,\n      this.grid.cellSize\n    );\n    //console.log(\"2: \" + this.grid.velocityX[0][0][0])\n    //console.log(this.particles.particleBuffer)\n    this.grid.velocityY = this.kernels.particleToYGrid(\n      particleBufferCopy,\n      this.grid.cellSize\n    );\n    //console.log(\"3: \" + this.grid.velocityX[0][0][0])\n    this.grid.velocityZ = this.kernels.particleToZGrid(\n      particleBufferCopy,\n      this.grid.cellSize\n    );\n\n    //console.log(\"4: \" + this.grid.velocityX[0][0][1])\n\n    // copy grid values to store the old ones\n    this.grid.pressureOld = this.kernels.copyPressure(this.grid.pressure);\n    this.grid.velocityXOld = this.kernels.copyXVelocity(this.grid.velocityX);\n    this.grid.velocityYOld = this.kernels.copyYVelocity(this.grid.velocityY);\n    this.grid.velocityZOld = this.kernels.copyZVelocity(this.grid.velocityZ);\n\n    // mark cells as solid, fluid, or air\n    this.grid.voxelStates = this.kernels.classifyVoxels(\n      this.grid.voxelStates.toArray(),\n      particleBufferCopy,\n      this.grid.cellSize\n    );\n\n    // perform gravity update\n    this.grid.velocityY = this.kernels.addGravity(this.grid.velocityY, dt);\n\n    // enforce boundary conditions\n    //this.grid.velocityX = this.kernels.enforceXBoundary(this.grid.velocityX);\n    this.grid.velocityY = this.kernels.enforceYBoundary(this.grid.velocityY);\n    //this.grid.velocityZ = this.kernels.enforceZBoundary(this.grid.velocityZ);\n\n    // do the pressure solve with a zero divergence velocity field\n    // TODO: implement this!\n\n    // enforce boundary conditions\n    // this.grid.velocityX = this.kernels.enforceXBoundary(this.grid.velocityX);\n    // this.grid.velocityY = this.kernels.enforceYBoundary(this.grid.velocityY);\n    // this.grid.velocityZ = this.kernels.enforceZBoundary(this.grid.velocityZ);\n\n\n    // update the velocities of the particles\n    console.log(\"PRE \" + this.particles.particleBuffer)\n    this.particles.particleBuffer = this.kernels.gridToParticles(\n      this.grid.velocityXOld,\n      this.grid.velocityYOld,\n      this.grid.velocityZOld,\n      this.grid.velocityX,\n      this.grid.velocityY,\n      this.grid.velocityZ,\n      particleBufferCopy\n    ).toArray();\n    console.log(\"POST \" + this.particles.particleBuffer)\n    // advect the particles to find their new positions\n    this.particles.particleBuffer = this.kernels.advectParticles(\n      new Float32Array(this.particles.particleBuffer),\n      dt,\n      this.grid.velocityX,\n      this.grid.velocityY,\n      this.grid.velocityZ\n    ).toArray();\n  }\n}\n","let adasd = 0;\nlet oldlog = console.log;\nconsole.log = function(text) {\n  if (adasd >= 2) {\n    return;\n  }\n  oldlog(text);\n  ++adasd;\n}\n\n\n/*\n * Copyright 2010, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n  \n// Marching cubes in Javascript\n//\n// Yes, this is madness. But this should test those JS engines!\n// Does not do simple optimizations like vertex sharing. Nevertheless,\n// performance is quite acceptable on Chrome.\n//\n// Converted from the standard C implementation that's all over the web.\n\nimport { vec3 } from \"gl-matrix\";\nimport { Simulation } from \"./simulation/simulation.js\";\n\nfunction MarchingCubesEffect(resolution) {\n  var ext = gl.getExtension(\"OES_texture_float\");\n  if (!ext) {\n    alert(\"this machine or browser does not support OES_texture_float\");\n    return;\n  }\n\n  var arrays = tdl.primitives.createCube(1.0)\n  var program = tdl.programs.loadProgramFromScriptTags(\n      \"ray_vs\", \"ray_fs\")\n  var textures = [new tdl.textures.ExternalTexture2D()]\n  \n\n  var view = new Float32Array(16)\n\n  var model = new tdl.models.Model(program, arrays, textures);\n\n  var eyePosition = new Float32Array([0, 1, 2.1])\n  var target = new Float32Array([0, 0, 0])\n\n  // Size of field. 32 is pushing it in Javascript :)\n  var size = resolution\n  // Deltas\n  var delta = 2.0 / size\n  var yd = size\n  var zd = size * size\n  var size3 = size * size * size\n  var max_tex_dim = 16384;\n  if (size3 > max_tex_dim * 4) {\n    alert(\"Resolution too high! Something's wrong.\");\n  }\n\n  //var array = cArray(max_tex_dim * 4);\n\n  //var field = array.data\n  var field = new Float32Array(max_tex_dim * 4);\n\n  var m4 = tdl.fast.matrix4\n\n  \n  var tex = textures[0].texture;\n  var tex_level = 0;\n  var tex_width = max_tex_dim;\n  var tex_height = 1;\n\n  gl.bindTexture(gl.TEXTURE_2D, tex);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n  // Temp buffers used in polygonize.\n  var vlist = new Float32Array(12 * 3)\n  var nlist = new Float32Array(12 * 3)\n\n  m4.lookAt(view, eyePosition, target, up);\n\n  function lerp(a,b,t) { return a + (b - a) * t; }\n  function VIntX(q,pout,nout,offset,isol,x,y,z,valp1,valp2) {\n    var mu = (isol - valp1) / (valp2 - valp1);\n    pout[offset + 0] = x + mu * delta;\n    pout[offset + 1] = y;\n    pout[offset + 2] = z;\n    nout[offset + 0] = lerp(normal_cache[q],   normal_cache[q+3], mu)\n    nout[offset + 1] = lerp(normal_cache[q+1], normal_cache[q+4], mu)\n    nout[offset + 2] = lerp(normal_cache[q+2], normal_cache[q+5], mu)\n  }\n  function VIntY(q,pout,nout,offset,isol,x,y,z,valp1,valp2) {\n    var mu = (isol - valp1) / (valp2 - valp1);\n    pout[offset + 0] = x;\n    pout[offset + 1] = y + mu * delta;\n    pout[offset + 2] = z;\n    var q2 = q + yd*3\n    nout[offset + 0] = lerp(normal_cache[q],   normal_cache[q2], mu)\n    nout[offset + 1] = lerp(normal_cache[q+1], normal_cache[q2+1], mu)\n    nout[offset + 2] = lerp(normal_cache[q+2], normal_cache[q2+2], mu)\n  }\n  function VIntZ(q,pout,nout,offset,isol,x,y,z,valp1,valp2) {\n    var mu = (isol - valp1) / (valp2 - valp1);\n    pout[offset + 0] = x;\n    pout[offset + 1] = y;\n    pout[offset + 2] = z + mu * delta\n    var q2 = q + zd*3\n    nout[offset + 0] = lerp(normal_cache[q],   normal_cache[q2], mu)\n    nout[offset + 1] = lerp(normal_cache[q+1], normal_cache[q2+1], mu)\n    nout[offset + 2] = lerp(normal_cache[q+2], normal_cache[q2+2], mu)\n  }\n\n  function compNorm(q) {\n    if (normal_cache[q*3] == 0.0) {\n      normal_cache[q*3    ] = field[q-1]  - field[q+1]\n      normal_cache[q*3 + 1] = field[q-yd] - field[q+yd]\n      normal_cache[q*3 + 2] = field[q-zd] - field[q+zd]\n    }\n  }\n\n  // Returns total number of triangles. Fills triangles.\n  // TODO: Optimize to death, add normal calculations so that we can run\n  // proper lighting shaders on the results. The grid parameter should be\n  // implicit and removed.\n  function polygonize(fx, fy, fz, q, isol) {\n    var cubeindex = 0;\n    var field0 = field[q]\n    var field1 = field[q+1]\n    var field2 = field[q+yd]\n    var field3 = field[q+1+yd]\n    var field4 = field[q+zd]\n    var field5 = field[q+1+zd]\n    var field6 = field[q+yd+zd]\n    var field7 = field[q+1+yd+zd]\n\n    if (field0 < isol) cubeindex |= 1;\n    if (field1 < isol) cubeindex |= 2;\n    if (field2 < isol) cubeindex |= 8;\n    if (field3 < isol) cubeindex |= 4;\n    if (field4 < isol) cubeindex |= 16;\n    if (field5 < isol) cubeindex |= 32;\n    if (field6 < isol) cubeindex |= 128;\n    if (field7 < isol) cubeindex |= 64;\n\n    // If cube is entirely in/out of the surface - bail, nothing to draw.\n    var bits = edgeTable[cubeindex]\n    if (bits == 0) return 0;\n\n    var d = delta\n    var fx2 = fx + d, fy2 = fy + d, fz2 = fz + d\n\n    // Top of the cube\n    if (bits & 1)    {compNorm(q);       compNorm(q+1);       VIntX(q*3,      vlist, nlist, 0, isol, fx,  fy,  fz, field0, field1); }\n    if (bits & 2)    {compNorm(q+1);     compNorm(q+1+yd);    VIntY((q+1)*3,  vlist, nlist, 3, isol, fx2, fy,  fz, field1, field3); }\n    if (bits & 4)    {compNorm(q+yd);    compNorm(q+1+yd);    VIntX((q+yd)*3, vlist, nlist, 6, isol, fx,  fy2, fz, field2, field3); }\n    if (bits & 8)    {compNorm(q);       compNorm(q+yd);      VIntY(q*3,      vlist, nlist, 9, isol, fx,  fy,  fz, field0, field2); }\n    // Bottom of the cube\n    if (bits & 16)   {compNorm(q+zd);    compNorm(q+1+zd);    VIntX((q+zd)*3,    vlist, nlist, 12, isol, fx,  fy,  fz2, field4, field5); }\n    if (bits & 32)   {compNorm(q+1+zd);  compNorm(q+1+yd+zd); VIntY((q+1+zd)*3,  vlist, nlist, 15, isol, fx2, fy,  fz2, field5, field7); }\n    if (bits & 64)   {compNorm(q+yd+zd); compNorm(q+1+yd+zd); VIntX((q+yd+zd)*3, vlist, nlist, 18, isol, fx,  fy2, fz2, field6, field7); }\n    if (bits & 128)  {compNorm(q+zd);    compNorm(q+yd+zd);   VIntY((q+zd)*3,    vlist, nlist, 21, isol, fx,  fy,  fz2, field4, field6); }\n    // Vertical lines of the cube\n    if (bits & 256)  {compNorm(q);       compNorm(q+zd);      VIntZ(q*3,        vlist, nlist, 24, isol, fx,  fy,  fz, field0, field4); }\n    if (bits & 512)  {compNorm(q+1);     compNorm(q+1+zd);    VIntZ((q+1)*3,    vlist, nlist, 27, isol, fx2, fy,  fz, field1, field5); }\n    if (bits & 1024) {compNorm(q+1+yd);  compNorm(q+1+yd+zd); VIntZ((q+1+yd)*3, vlist, nlist, 30, isol, fx2, fy2, fz, field3, field7); }\n    if (bits & 2048) {compNorm(q+yd);    compNorm(q+yd+zd);   VIntZ((q+yd)*3,   vlist, nlist, 33, isol, fx,  fy2, fz, field2, field6); }\n\n    cubeindex <<= 4  // Re-purpose cubeindex into an offset into triTable.\n    var numtris = 0, i = 0;\n    while (triTable[cubeindex + i] != -1) {\n      imm.posnormtriv(vlist, nlist,\n                      3 * triTable[cubeindex + i + 0],\n                      3 * triTable[cubeindex + i + 1],\n                      3 * triTable[cubeindex + i + 2])\n      i += 3;\n      numtris++;\n    }\n    return numtris;\n  }\n\n  function smin(a, b, k) {\n    h = Math.min(1, Math.max(0, 0.5+0.5*(b-a)/k));\n    return b * (1 - h) + a * h - k*h*(1.0-h);\n  }\n\n  function sphereSDF(x, y, z, r) {\n    return Math.sqrt(x*x + y*y + z*z) - r;\n  }\n\n  // Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after\n  // a fixed distance, determined by strength and subtract.\n  function addBallOld(ballx, bally, ballz, strength, subtract) {\n    // Let's solve the equation to find the radius:\n    // 1.0 / (0.000001 + radius^2) * strength - subtract = 0\n    // strength / (radius^2) = subtract\n    // strength = subtract * radius^2\n    // radius^2 = strength / subtract\n    // radius = sqrt(strength / subtract)\n    var radius = size * Math.sqrt(strength / subtract)\n    var min_z = Math.floor(ballz * size - radius); if (min_z < 1) {min_z = 1;}\n    var max_z = Math.floor(ballz * size + radius); if (max_z > size - 1) max_z = size - 1\n    var min_y = Math.floor(bally * size - radius); if (min_y < 1) min_y = 1\n    var max_y = Math.floor(bally * size + radius); if (max_y > size - 1) max_y = size - 1\n    var min_x = Math.floor(ballx * size - radius); if (min_x < 1) min_x = 1\n    var max_x = Math.floor(ballx * size + radius); if (max_x > size - 1) max_x = size - 1\n    // Don't polygonize in the outer layer because normals aren't\n    // well-defined there.\n    for (var z = min_z; z < max_z; z++) {\n      var z_offset = size * size * z;\n      var fz = z / size - ballz\n      var fz2 = fz * fz\n      for (var y = min_y; y < max_y; y++) {\n        var y_offset = z_offset + size * y;\n        var fy = y / size - bally\n        var fy2 = fy * fy\n        for (var x = min_x; x < max_x; x++) {\n          var fx = x / size - ballx\n          var val = strength / (0.000001 + fx*fx + fy2 + fz2) - subtract\n          if (val > 0.0) field[y_offset + x] += val\n        }\n      }\n    }\n  }\n\n  function addBall(x_c, y_c, z_c, radius) {\n    for (var z = 0; z < size; ++z) {\n      var z_offset = size * size * z;\n      var z_w = z / size;\n\n      for (var y = 0; y < size; ++y) {\n        var y_offset = z_offset + size * y;\n        var y_w = y / size;\n\n        for (var x = 0; x < size; ++x) {\n          var x_w = x / size;\n          \n          field[y_offset + x] = Math.min(field[y_offset + x], sphereSDF(x_w - x_c, y_w - y_c, z_w - z_c, radius), 0.05);\n          //if (z == 0)\n          //console.log(sphereSDF(x_w - x, y_w - y, z_w - z))\n        }\n      }\n    }\n  }\n\n  function addFloor(strength, subtract) {\n    var dist = size * Math.sqrt(strength / subtract)\n    if (dist > size) dist = size\n    for (var y = 0; y < dist; y++) {\n      var yy = (y / size) * (y / size)\n      var val = strength / (0.0001 + yy) - subtract\n      if (val > 0.0) {\n        for (var x = 0; x < size; x++)\n          for (var z = 0; z < size; z++)\n            field[zd * z + y * yd + x] += val\n      }\n    }\n  }\n\n  var firstDraw = true\n  var startTime = Date.now() / 1000;\n  var lastTime = startTime;\n\n  const gpu = new GPU();\n  const sim = new Simulation(gpu, {\n    particleDensity: 2000,\n    particleBounds: {\n      min: vec3.fromValues(0.3, 0.3, 0.3),\n      max: vec3.fromValues(0.7, 0.7, 0.7),\n    },\n    gridBounds: {\n      min: vec3.fromValues(0.1, 0.1, 0.1),\n      max: vec3.fromValues(0.9, 0.9, 0.9),\n    },\n  });\n\n  const fillField = gpu.createKernel(function(balls, n, size, radius) {\n      let z = Math.floor(this.thread.x / (size * size));\n      let y = Math.floor(this.thread.x / size) % size;\n      let x = this.thread.x % size;\n      var z_w = z / size;\n      var y_w = y / size;\n      var x_w = x / size;\n      let closest = 0;\n      let best = 100000;\n      // if n too big will need to change loopmaxiterations\n      for (let i = 0; i < n; ++i) {\n        let cur = (x_w - balls[i][0]) * (x_w - balls[i][0]) + (y_w - balls[i][1]) * (y_w - balls[i][1]) + (z_w - balls[i][2]) * (z_w - balls[i][2]);\n        if (cur < best) {\n          best = cur;\n          closest = i;\n        }\n      }\n      \n      //field[y_offset + x] = sphereSDF(x_w - balls[closest][0], y_w - balls[closest][1], z_w - balls[closest][2], radius);\n      return Math.sqrt((x_w - balls[closest][0]) * (x_w - balls[closest][0]) + \n             (y_w - balls[closest][1]) * (y_w - balls[closest][1]) + \n             (z_w - balls[closest][2]) * (z_w - balls[closest][2])) - radius;\n  }).setLoopMaxIterations(10000).setPipeline(true).setOutput([max_tex_dim * 4]);\n\n  const smooth = gpu.createKernel(function(field, size) {\n    let z_c = Math.floor(this.thread.x / (size * size));\n    let y_c = Math.floor(this.thread.x / size) % size;\n    let x_c = this.thread.x % size;\n\n    let sum = 0;\n    let count = 0.001; // weight must be nonzero\n    let r = 2;\n    for (let z_o = -r; z_o <= r; ++z_o) {\n      for (let y_o = -r; y_o <= r; ++y_o) {\n        for (let x_o = -r; x_o <= r; ++x_o) {\n          let x = x_c + x_o;\n          let y = y_c + y_o;\n          let z = z_c + z_o;\n          \n          let w = Math.pow(2.71, -1.5 * Math.sqrt(x_o * x_o + y_o * y_o + z_o * z_o));\n\n          if (x < 0 || x > size-1 || y < 0 || y > size-1 || z < 0 || z > size-1) {\n            // cheaper than continue, will try to read invalid data\n            w = 0.0;\n          }\n          \n          //let w = x_o == 0 && y_o == 0 && z_o == 0 ? 1.0 : 0.0;\n          \n          sum += field[z * size * size + y * size + x] * w;\n          count += w;\n        }\n      }\n    }\n\n    return sum / count;\n  }).setPipeline(true).setOutput([max_tex_dim * 4]);\n\n  this.render = function(framebuffer, time, numblobs) {\n    /*m4.perspective(proj, tdl.math.degToRad(60), aspect, 0.1, 500);\n    m4.rotationY(world, 0);//time * 0.5)\n    m4.translate(world, [0, 0, 0])\n    m4.mul(viewproj, view, proj)\n    m4.mul(worldview, world, view)\n    m4.mul(worldviewproj, world, viewproj)*/\n\n    gl.clearColor(0.0,0.0,0.0,1)\n    gl.clearDepth(1.0)\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n    gl.enable(gl.DEPTH_TEST)\n    gl.enable(gl.CULL_FACE)\n\n    let curTime = Date.now() / 1000;\n    let deltaTime = curTime - lastTime;\n    lastTime = curTime;\n\n    let localTime = Date.now() / 1000 - startTime;\n\n    if (deltaTime > 1/20) {\n      deltaTime = 1/20;\n    }\n\n    //console.log(sim.particles.get(0));\n    //console.log(sim.grid.velocityX[0][0][0]);\n    sim.step(deltaTime);\n    \n\n    var uniformsConst = {\n      //u_worldviewproj: worldviewproj,\n      //u_worldview: worldview,\n      //u_world: world,\n      //u_lightDir: [-1.0, 1.0, 1.0],\n      //u_lightColor: [116 / 255.0, 204 / 255.0, 244 / 255.0, 1.0],\n      //u_ambientUp: [35 / 255.0 * 0.5, 137 / 255.0 * 0.5, 218 / 255.0 * 0.5, 1.0],\n      //u_ambientDown: [15 / 255.0 * 0.5, 94 / 255.0 * 0.5, 156 / 255.0 * 0.5, 1.0],\n      u_field: textures[0],\n      time: localTime\n    }\n\n    model.drawPrep(uniformsConst)\n\n    if (firstDraw) {\n      // Uncomment to check the speed impact of the field filling.\n      //firstDraw = false\n      //for (var i = 0; i < size * size * size; i++) {\n      // field[i] = 100000.0\n      //}\n     /*\n      let balls = [];\n      let n = 30;\n      let radius = 0.04;\n      \n      for (let x = 0; x < n; ++x) {\n        for (let z = 0; z < n; ++z) {\n          let xp = (x+0.5) / n;\n          let zp = (z+0.5) / n;\n          let r = Math.sqrt((xp-0.5) * (xp-0.5) + (zp-0.5) * (zp-0.5));\n          //let y = 0.1*((Math.sin(40 * r - 1.5*time) + 1) / 2) / Math.abs(10*(Math.max(r, 0.013))) + 0.05;\n          let y = 0.3 * Math.pow(Math.cos(10 * r - 1 * time), 2) / Math.max(10*r, 0.5) + 0.05;\n          balls.push([xp, y, zp]);\n        }\n      }*/\n      \n      let balls = [];\n      let radius = 0.05;\n      for (let i = 0; i < sim.particles.particleBuffer.length; i += 6) {\n        balls.push([sim.particles.particleBuffer[i], sim.particles.particleBuffer[i+1], sim.particles.particleBuffer[i+2]]);\n      }\n      field = fillField(balls, balls.length, size, radius).toArray()\n      //field = smooth(fillField(balls, balls.length, size, radius), size).toArray();\n    }\n\n    var isol = 80.0\n    imm.begin(gl.TRIANGLES, program);\n\n    /*field[0] = 0.0;\n    field[1] = 1.0;\n    field[2] = 0.0;\n    //field[4] = 0.0;\n    field[size + 0] = 0.0;\n    field[size + 1] = 0.0;\n    field[size + 2] = 1.0;\n    field[size * size + 0] = 1.0;\n    field[size * size + 1] = 0.0;\n    field[size * size + 2] = 0.0;\n    field[(size - 1) * size * size + 0] = 0.0;\n    field[(size - 1) * size * size + 1] = 1.0;\n    field[(size - 1) * size * size + 2] = 0.0;\n    \n    field[(size - 1) * size * size + (size-1) * size + 0] = 0.0;\n    field[(size - 1) * size * size + (size-1) * size + 1] = 0.0;\n    field[(size - 1) * size * size + (size-1) * size + 2] = 1.0;\n\n    \n    field[(size - 1) * size * size + (size-1) * size + (size-3)] = 1.0;\n    field[(size - 1) * size * size + (size-1) * size + (size-2)] = 0.0;\n    field[(size - 1) * size * size + (size-1) * size + (size-1)] = 0.0;*/\n\n    /*for (let i = 0; i < size; ++i) {\n      for (let j = 0; j < size; ++j) {\n        field[i * size + j] = (1 + Math.sin(5*(i/size + j/size))) / 2;\n      }\n    }*/\n    \n    gl.bindTexture(gl.TEXTURE_2D, tex);\n    gl.texImage2D(gl.TEXTURE_2D, tex_level, gl.RGBA, tex_width, tex_height, 0, gl.RGBA, gl.FLOAT, field);\n\n    gl.activeTexture(gl.TEXTURE0);\n\n    imm.quad2d(-1, -1, 2, 2, 1);\n\n    /*// Triangulate. Yeah, this is slow.\n    var size2 = size / 2.0\n    for (var z = 2; z < size - 2; z++) {\n      var z_offset = size * size * z;\n      var fz = (z - size2) / size2 //+ 1\n      for (var y = 2; y < size - 2; y++) {\n        var y_offset = z_offset + size * y;\n        var fy = (y - size2) / size2 //+ 1\n        for (var x = 2; x < size - 2; x++) {\n          var fx = (x - size2) / size2 //+ 1\n          var q = y_offset + x\n          polygonize(fx, fy, fz, q, isol)\n        }\n      }\n    }*/\n    imm.end();\n  }\n}\n\nwindow.MarchingCubesEffect = MarchingCubesEffect;"],"names":["glMatrix.ARRAY_TYPE","vec3.set","vec3.create","vec3.sub","vec3.scale","vec3.add","vec3.fromValues","vec3.floor"],"mappings":"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"}